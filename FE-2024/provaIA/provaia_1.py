# -*- coding: utf-8 -*-
"""provaIA_1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DHH8CtXC4d7HwdVr0eSi6_gLeXxuMR9f

#**Bibliotecas**
"""

# Manipulação de dados
import pandas as pd
import numpy as np
# Visualização
import plotly.express as px
import plotly.graph_objects as go
import plotly.figure_factory as ff
from plotly.subplots import make_subplots
# Pré-processamento
from sklearn.preprocessing import (
    LabelEncoder,
    StandardScaler,
    OneHotEncoder
)
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
# Treinamento
from sklearn.model_selection import(
    train_test_split,
    GridSearchCV,
    cross_val_score,
    KFold,
    cross_validate)
# Algoritmos
from sklearn.datasets import load_iris
from sklearn.ensemble import RandomForestRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.linear_model import LinearRegression
# Avaliação
from sklearn.metrics import (
    accuracy_score,
    classification_report,
    confusion_matrix)
# Métricas
from sklearn.metrics import mean_squared_error, r2_score

#Ignorar alertas
import warnings
warnings.filterwarnings("ignore")

"""#Dados"""

#Carregar a base

df = pd.read_csv('/content/aluguel.csv')
df.head(5)

# Verificar informações
df.info()

# Verificar NaN
df.isna().sum()

# Descritivas
df.describe().T.round(2)

#Substituir os valores de vagas

df['vagasgerais'] = df['vagas'].replace({
    0: 'nao', 1: 'sim' , 2: 'sim' , 3: 'sim' , 4: 'sim' , 5: 'sim' , 6: 'sim' , 7: 'sim' , 8: 'sim' , 9: 'sim' , 10: 'sim' , 11: 'sim' , 12: 'sim'
})

df['vagasgerais']

# Selecionar colunas numéricas
colunas_numericas = df.select_dtypes(include=['int','float']).columns
colunas_numericas

# Selecionar colunas categóricas
colunas_categoricas = df.select_dtypes(include=['object']).columns
colunas_categoricas

# Alterar para números
cols = ['area', 'quartos', 'banheiros', 'andar','totalAluguel' ]

for col in cols:
  df[col] = pd.to_numeric(df[col], errors = 'coerce')

  df.info()

"""#EDA"""

# Estatísticas descritivas
df.describe().T.round(2)

# Médias por cidade
pd.pivot_table(df, index='cidade',
               values=colunas_numericas,
               aggfunc={'mean', 'std'}).round(2)

contagem_cidades = df['cidade'].value_counts()

# Exibir as cidades mais frequentes
print("As cidades que mais aparecem nos dados são:")
print(contagem_cidades.head(5))

# Classe para gerar os gráficos
class Graficos:
    def __init__(self, df):
        self.df = df

    def boxplot_por_cidade(self, col1, col_cidade='cidade'):
        fig = px.box(self.df,
                     x=col_cidade, y=col1,
                     color = col_cidade,
                     template='plotly_dark')

        fig.update_layout(xaxis_title='Cidade', yaxis_title=col1)

        fig.show()

    def barras(self, col1):
        counts = self.df[col1].value_counts()

        # Criar gráfico de barras
        fig = px.bar(x=counts.index,
                     y=counts.values,
                     text_auto = True,
                     template='plotly_dark')

        fig.update_traces(textposition='outside')

        fig.update_layout(xaxis_title=col1,
                          yaxis_title='Contagem',
                          )

        fig.show()

# Criar o objeto
graficos = Graficos(df)

# Barras
for col in colunas_categoricas:
    graficos.barras(col)

# Boxplot gêneros
for col in colunas_numericas:
    graficos.boxplot_por_cidade(col)

#Determinando as percentagens de animais aceitos com base nas variáveis.

variaveis = ['cidade']
for v in variaveis:
  resultado = df.groupby(v)['animal'].value_counts(normalize=True).unstack()
  print(f"\Determinando as percentagens de animais aceitos com base na variável'{v}' :")
  print(resultado)

pd.pivot_table(df, index='cidade',
               values=colunas_numericas,
               aggfunc={'mean', 'std'}).round(2)

#Cálculo da média do número de banheiros em imóveis com animais em relação aos
#que não tem

pd.pivot_table(df, index='animal',
               values='banheiros',
               aggfunc={'mean', 'std'}).round(2)

# Calculando a média da área dos imóveis
media_por_cidade = df.groupby('cidade')['area'].mean().reset_index()

# Criando o gráfico de barras
fig = px.bar(media_por_cidade, x='cidade', y='area',
             template='plotly_dark',
             title='Média da área dos imóveis para alugar em cada cidade')

# Exibindo o gráfico
fig.show()

#Correlaçao de todos os dados
numeric_df = df.select_dtypes(include='number')

# Calcula a matriz de correlação entre todas as variáveis numéricas
corr = numeric_df.corr()

corr_styled = corr.style.background_gradient()


corr_styled

# Calcular a média do preço do aluguel para cada grupo
media_aluguel = df.groupby('animal')['totalAluguel'].mean().reset_index()

# Criar um gráfico de barras com Plotly Express
fig = px.bar(media_aluguel, x='animal', y='totalAluguel',
             labels={'animal': 'Permite Animais', 'totalAluguel': 'Média do Preço do Aluguel'},
             template='plotly_dark',
             title='Média do Preço do Aluguel por Permissão de Animais de Estimação',
           )

fig.show()

# Calculando a média de preço de aluguel em relação com a cidade
media_por_cidade = df.groupby('cidade')['totalAluguel'].mean().reset_index()

# Criando o gráfico de barras
fig = px.bar(media_por_cidade, x='cidade', y='totalAluguel',
             template='plotly_dark',
             labels={'cidade': 'Cidades', 'totalAluguel': 'Média de preço dos aluguéis'},
             title='Média de preço de aluguel em relação com a cidade')

# Exibindo o gráfico
fig.show()

# Calculando a média de preço de aluguel em relação com a cidade
media_por_cidade = df.groupby('vagas')['totalAluguel'].mean().reset_index()

# Criando o gráfico de barras
fig = px.bar(media_por_cidade, x='vagas', y='totalAluguel',
             template='plotly_dark',
             labels={'vagas': 'vagas', 'totalAluguel': 'valor do aluguel'},
             title='Média dos preços de alugueis em relação a quantidade de vagas.')

# Definindo todos os números no eixo x
fig.update_xaxes(tickmode='array', tickvals=list(media_por_cidade['vagas']))

# Exibindo o gráfico
fig.show()

# Relacionar a proporção com o preço do aluguel em cada cidade
media_por_cidade_com_vaga = df[df['vagas'] > 0].groupby('cidade').agg({'totalAluguel': 'mean'})
media_por_cidade_sem_vaga = df[df['vagas'] == 0].groupby('cidade').agg({'totalAluguel': 'mean'})

print("\nMédia do preço do aluguel em cada cidade para imóveis com vaga de garagem:")
print(media_por_cidade_com_vaga)
print("\nMédia do preço do aluguel em cada cidade para imóveis sem vaga de garagem:")
print(media_por_cidade_sem_vaga)

# Relacionar a proporção com o preço do aluguel em cada cidade
media_por_cidade_com_vaga = df[df['vagas'] > 0].groupby('cidade').agg({'totalAluguel': 'mean'})
media_por_cidade_sem_vaga = df[df['vagas'] == 0].groupby('cidade').agg({'totalAluguel': 'mean'})

# Criar gráfico para imóveis com vaga de garagem
fig1 = px.bar(media_por_cidade_com_vaga, x=media_por_cidade_com_vaga.index, y='totalAluguel',
               title='Média do Preço do Aluguel em Cada Cidade para Imóveis com Vaga de Garagem',
               labels={'totalAluguel': 'Preço do Aluguel', 'cidade': 'Cidade'}, template='plotly_dark')

# Criar gráfico para imóveis sem vaga de garagem
fig2 = px.bar(media_por_cidade_sem_vaga, x=media_por_cidade_sem_vaga.index, y='totalAluguel',
               title='Média do Preço do Aluguel em Cada Cidade para Imóveis sem Vaga de Garagem',
               labels={'totalAluguel': 'Preço do Aluguel', 'cidade': 'Cidade'}, template='plotly_dark')

# Exibir os gráficos
fig1.show()
fig2.show()

"""# Treinamento e Processamento

"""

# Substitui no DataFrame
df['cidade'] = df['cidade'].replace({
    'São Paulo': 1,
    'Campinas': 2,
    'Porto Alegre': 3,
    'Belo Horizonte': 4,
    'Rio de Janeiro': 5
})

df.drop('vagasgerais',axis=1, inplace=True)

df.head(5)

# Criar X e y
X = df.iloc[:,: -1]
y = df.iloc[:,-1]

# Codificar alvo
le = LabelEncoder()
y = le.fit_transform(y)

# Armazenar os valores reais de y
labels = list(le.classes_)
labels

# Criar o pipeline para escalonar os dados
pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('modelo', None)
])

X_train, X_test, y_train, y_test = train_test_split(X, y,
                                                    test_size=0.2,
                                                    random_state = 42)

# Definir uma grade de hiperparâmetros
param_grid = [{
    'modelo': [RandomForestRegressor(random_state =42)],
    'modelo__n_estimators': [50, 100, 150],
    'modelo__max_depth': [5, 10, 15],

    },
    {
    'modelo': [DecisionTreeRegressor(random_state=42)],
    'modelo__max_depth': [3,5,7,10],
    'modelo__min_samples_split': [2,5,10]
    },
    {
    'modelo': [LinearRegression()],
    'modelo__fit_intercept': ['True', 'False'],
    }
]

# Criar o objeto Grid Search
grid_search = GridSearchCV(pipeline, param_grid, cv = 3,
                           scoring = 'accuracy',
                           verbose =1,
                           n_jobs = -1)

# Treinar
grid_search.fit(X_train, y_train)

print(f"Melhores hiperparâmetros:"
      f"{grid_search.best_params_}")

# Melhor modelo (hiperparâmetros)
melhor_modelo = grid_search.best_estimator_
melhor_modelo

# testar
rf = RandomForestRegressor(max_depth=5, n_estimators=50, random_state=42)
rf.fit(X_train, y_train)
y_pred = melhor_modelo.predict(X_test)

# Avaliar o modelo
mse = mean_squared_error(y_test,y_pred)
r2  = r2_score(y_test,y_pred)
print(f"Erro Quadrático Médio (Teste): {mse.round(2)}\n"
      f"R2 (Teste): {r2.round(2)}")

# Criar figura
fig = go.Figure()

# Adicionar linha de tendência (valores reais)
fig.add_trace(go.Scatter(x=y_test,
                         y=y_test,
                         mode='lines',
                         name='Real',
                         line=dict(color='blue')))

# Adicionar pontos para valores previstos
fig.add_trace(go.Scatter(x=y_test,
                         y=y_pred,
                         mode='markers',
                         name='Previsto',
                         marker=dict(color='red')))

# Layout do gráfico
fig.update_layout(title='Comparação entre Valores Reais e Previstos',
                  xaxis_title='Valores Reais',
                  yaxis_title='Valores Previstos',
                  showlegend=True)

# Exibir gráfico
fig.show()

# Obter a importância das características
importancias = rf.feature_importances_

# Montar a equação com as características mais importantes
equacao_rf = 'totalAluguel = '
for i in range(len(df.columns[:-1])):
    equacao_rf += f'{importancias[i]:.2f} * {df.columns[i]} + '

# Montar a equação com as características mais importantes
equacao_rf = 'totalAluguel = '
for i in range(len(df.columns[:-1])):
    equacao_rf += f'{importancias[i]:.2f} * {df.columns[i]} + '

# Remover o último sinal de adição
equacao_rf = equacao_rf

equacao_rf[:-3]

# Nome das características
nomes_caracteristicas = df.columns[:-1]

# Criar o gráfico de radar
fig = go.Figure()

fig.add_trace(go.Scatterpolar(
      r=importancias,
      theta=nomes_caracteristicas,
      fill='toself',
      name='Importância das Características'
))

fig.update_layout(
  polar=dict(
    radialaxis=dict(
      visible=True,
      range=[0, max(importancias)]
    )),
  showlegend=True
)

fig.show()